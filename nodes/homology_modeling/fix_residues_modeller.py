import json  # noqa: E402
import os
import re
import sys
import textwrap
from collections import OrderedDict
from datetime import datetime

import numpy as np

# import execution dependent modules
from modeller import environ, log
from modeller.automodel import LoopModel, refine

from bocoflow_core import WorkflowException
from bocoflow_core.logger import log_message
from bocoflow_core.node import Node, NodeException, NodeResult
from bocoflow_core.parameters import *

#  Modeller 10.5
#  Install via conda: https://salilab.org/modeller/10.5/release.html#anaconda
#  e.g.
#  conda-env list
#  conda activate mdflow
#  conda install salilab::modeller
#
# The following NEW packages will be INSTALLED:
#   hdf5-1107          salilab/osx-64::hdf5-1107-1.10.7-1
#   modeller           salilab/osx-64::modeller-10.5-py39h254f028_0
# The following packages will be REMOVED:
#   libllvm19-19.1.1-h308e1d1_0
# The following packages will be UPDATED:
#   openssl                                  3.1.3-h8a1eda9_0 --> 3.1.7-hd23fc13_0
# https://salilab.org/modeller/wiki/Missing_residues


class FixMissResModeller(Node):
    """FixMissResModeller

    This node uses MODELLER to fix missing residues in protein structures by performing
    homology modeling on the gaps while maintaining the known structure regions.

    [ Function ]
    - repairs missing residues in protein structures
    - performs loop modeling for gap regions
    - maintains existing structure as template
    - handles multi-chain proteins
    - supports both protein and DNA/RNA chains
    - uses fast refinement level for loop modeling
    - preserves HETATM records
    - generates complete structure models

    [ Input ]
    - Case name (optional, can use predecessor data)
    - Input PDB file with missing residues
    - Alignment file (.ali format) from GenAlignFileNode
    - Force run option for bypassing database checks

    [ Output ]
    Files:
    - Complete PDB structure with fixed residues
    - MODELLER output files and logs

    Data:
    - Path to output PDB file

    [ Note ]
    The node requires proper MODELLER installation through conda and a valid license key.
    It uses the alignment files generated by GenAlignFileNode and performs loop modeling
    with fast refinement to balance speed and accuracy.
    """

    # Basic configuration
    name = "FixMissResModeller"
    node_key = "FixMissResModeller"
    color = "purple"
    num_in = 1
    num_out = 1

    # Define the parameters for GUI
    OPTIONS = {
        "case_name": StringParameter(
            label="Case Name",
            default="",
            docstring="Name of the case/protein (leave empty to use predecessor data)",
            optional=True,
        ),
        "input_pdb_file": FileParameterEdit(
            label="Input PDB File",
            docstring="Input PDB file to be processed (select file or enter path)",
            optional=False,
        ),
        "input_ali_file": FileParameterEdit(
            label="Alignment File",
            docstring="Path to Alignment file (select file or enter path)",
            optional=False,
        ),
        "force_to_run": BooleanParameter(
            "Force to Run",
            default=False,
            docstring="If true, the node will be executed regardless of the database record",
            optional=True,
        ),
    }

    def execute(self, predecessor_data, flow_vars):
        try:
            # Initialize standard result
            result = NodeResult()

            # Parse the input data
            input_data = predecessor_data[0] if predecessor_data else {}

            # Use predecessor data if case_name is empty
            case_name = flow_vars["case_name"].get_value() or input_data.get(
                "metadata", {}
            ).get("case_name")
            input_pdb_file = flow_vars["input_pdb_file"].get_value()
            input_ali_file = flow_vars["input_ali_file"].get_value()

            # Give error if compulsory variables are not provided
            if not case_name or not input_pdb_file or not input_ali_file:
                raise NodeException(self.name, "Please complete node configuration")

            # Resolve input paths if they have URI prefixes
            resolved_input_pdb_file = (
                self.resolve_path(input_pdb_file)
                if hasattr(self, "resolve_path")
                else input_pdb_file
            )
            resolved_input_ali_file = (
                self.resolve_path(input_ali_file)
                if hasattr(self, "resolve_path")
                else input_ali_file
            )

            log_message(f"Resolved input PDB file: {resolved_input_pdb_file}")
            log_message(f"Resolved input ALI file: {resolved_input_ali_file}")

            # Get the folder of the input file (using resolved path)
            work_path = os.path.dirname(resolved_input_pdb_file)
            log_message(f"Working path: {work_path}")

            # Record input files with URI prefixes
            result.files["input"].update(
                {
                    "input_pdb_file": (
                        self.format_output_path(resolved_input_pdb_file)
                        if hasattr(self, "format_output_path")
                        else input_pdb_file
                    ),
                    "input_ali_file": (
                        self.format_output_path(resolved_input_ali_file)
                        if hasattr(self, "format_output_path")
                        else input_ali_file
                    ),
                }
            )

            # Call the processing function with resolved paths
            processing_result = fix_missing_multi_chain_modeller(
                case_name, work_path, resolved_input_ali_file
            )

            if "error" in processing_result:
                raise NodeException(self.name, processing_result["error"])

            # Get the output PDB file path and format it with URI prefix
            out_pdb_file = processing_result.get("out_pdb_file")
            formatted_out_pdb_file = (
                self.format_output_path(out_pdb_file)
                if hasattr(self, "format_output_path") and out_pdb_file
                else out_pdb_file
            )

            # Store processing results
            result.data.update({"out_pdb_file": formatted_out_pdb_file})

            # Record output files with formatted paths
            result.files["output"].update({"output_pdb_file": formatted_out_pdb_file})

            # Update metadata
            result.metadata.update(
                {
                    "case_name": case_name,
                    "execution_time": datetime.now().isoformat(),
                    "work_path": (
                        self.format_output_path(work_path)
                        if hasattr(self, "format_output_path")
                        else work_path
                    ),
                }
            )

            # Store key data for downstream nodes
            result.data.update(
                {"case_name": case_name, "output_pdb_file": formatted_out_pdb_file}
            )

            # If there was predecessor data, preserve essential data
            if predecessor_data:
                for key in ["output_dir", "working_path"]:
                    if key in input_data.get("data", {}) and key not in result.data:
                        result.data[key] = input_data["data"][key]

            result.success = True
            result.message = "Successfully fixed missing residues with MODELLER"

            return result.to_json()

        except Exception as e:
            log_message(f"Error in FixMissResModeller: {str(e)}")
            raise NodeException(self.name, str(e))


def fix_missing_multi_chain_modeller(case_name, work_path, input_ali_file):
    """Fix missing residues in multi-chain protein structures using MODELLER.

    This function works with resolved filesystem paths (no URI prefixes).
    All paths passed in should already be resolved by the execute function.
    All paths returned will be unformatted filesystem paths.

    Args:
        case_name: Name of the case/protein
        work_path: Directory path where MODELLER will run
        input_ali_file: Path to the alignment file in MODELLER format

    Returns:
        Dictionary containing:
        - out_pdb_file: Path to the output PDB file with fixed residues
        - error: Error message if processing failed
    """
    try:
        # Import MODELLER modules
        try:
            from modeller import environ, log
            from modeller.automodel import LoopModel, refine
        except ImportError:
            return {
                "error": "MODELLER is required but not installed. Install with: conda install salilab::modeller"
            }

        log_message(f"Starting MODELLER for case: {case_name}")
        log_message(f"Working directory: {work_path}")
        log_message(f"Input alignment file: {input_ali_file}")

        # Get just the filename from the full path for MODELLER
        ali_filename = os.path.basename(input_ali_file)

        # Store current directory to return to it later
        current_dir = os.getcwd()

        # Change to the work directory
        os.chdir(work_path)
        log_message(f"Changed directory to: {work_path}")

        # Set up MODELLER environment
        log.verbose()
        env = environ()
        env.io.atom_files_directory = [work_path, "."]
        env.io.hetatm = True

        # Configure MODELLER loop model
        log_message(
            f"Setting up MODELLER LoopModel with alignment file: {ali_filename}"
        )
        a = LoopModel(
            env, alnfile=ali_filename, knowns=case_name, sequence=case_name + "_full"
        )

        a.starting_model = 1
        a.ending_model = 1

        a.loop.starting_model = 1
        a.loop.ending_model = 2
        a.loop.md_level = refine.fast

        # Run MODELLER
        log_message("Running MODELLER loop modeling...")
        try:
            a.make()
            log_message("MODELLER completed successfully")
        except Exception as e:
            log_message(f"MODELLER error: {str(e)}")
            # Continue to check if output was generated despite error

        # Change back to original directory
        os.chdir(current_dir)
        log_message(f"Changed directory back to: {current_dir}")

        # Expected output file path
        out_pdb_file = os.path.join(
            work_path, case_name + "_full" + ".B99990001" + ".pdb"
        )

        # Check if output file exists
        if os.path.isfile(out_pdb_file):
            log_message(f"Output PDB file generated: {out_pdb_file}")
            return {"out_pdb_file": out_pdb_file}
        else:
            error_msg = (
                f"MODELLER did not generate the expected output file: {out_pdb_file}"
            )
            log_message(error_msg)
            return {"error": error_msg}

    except Exception as e:
        error_msg = f"Error in fix_missing_multi_chain_modeller: {str(e)}"
        log_message(error_msg)
        return {"error": error_msg}
